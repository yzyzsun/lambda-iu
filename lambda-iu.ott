embed
{{ tex-preamble
\usepackage{bbold}
\DeclareSymbolFont{bbsymbol}{U}{bbold}{m}{n}
\DeclareMathSymbol{\bbcomma}{\mathbin}{bbsymbol}{"2C}
}}

embed
{{ coq
Set Implicit Arguments.

Definition one (C : Type) (item : C) : list C := cons item nil.
Notation "x ~ a" := (one (x, a)) (at level 50) : list_scope.

Fixpoint dom
  (C : Type) (E : list (nat*C)) : list nat :=
  match E with
    | nil => nil
    | (x, _) :: E' => x :: dom E'
  end.

Definition binds
  (A : Type) (x : nat) (a : A) (E : list (nat*A)) : Prop :=
  In (x, a) E.

Definition fresh
  (A : Type) (x : nat) (E : list (nat*A)) : Prop :=
  ~ In x (dom E).

Inductive uniq (A : Type) : list (nat*A) -> Prop :=
  | uniq_nil :
      uniq nil
  | uniq_cons : forall x a E,
      uniq E ->
      fresh x E ->
      uniq (x ~ a ++ E).

Unset Implicit Arguments.
}}

metavar var, x, y, z, l {{ tex \ell }} ::=  {{ coq nat }} {{ com variable/label }}

grammar

%%%%% target calculus %%%%%

typ, A, B, C :: 't_' ::= {{ com types }}
  | Top        ::  :: top    {{ com top type }} {{ tex \top }}
  | Bot        ::  :: bot    {{ com bottom type }} {{ tex \bot }}
  | Null       ::  :: null   {{ com null type }}
  | Int        ::  :: int    {{ com integer type }} {{ tex \mathbb{Z} }}
  | A -> B     ::  :: arrow  {{ com function type }}
  | { l : A }  ::  :: rcd    {{ com record type }}
  | A & B      ::  :: and    {{ com intersection type }}
  | A | B      ::  :: or     {{ com union type }}
  | ( A )      :: S:: paren  {{ coq ([[A]]) }}

exp, e :: 'e_' ::= {{ com expressions }}
  | {}               ::  :: top    {{ com top value }}
  | null             ::  :: null   {{ com null value }}
  | int              ::  :: int    {{ com integer literal }} {{ tex n }}
  | x                ::  :: var    {{ com variable }}
  | \ x : A . e : B  ::  :: abs    {{ com abstraction }} {{ tex [[\]][[x]]\!:\![[A]].\;[[e]]\!:\![[B]] }}
  | e1 e2            ::  :: app    {{ com application }}
  | { l = e }        ::  :: rcd    {{ com record }}
  | e . l            ::  :: prj    {{ com projection }}
  | e1 ,, e2         ::  :: merge  {{ com merging }}
  | switch e0 as x case A => e1 case B => e2
                     ::  :: switch {{ com type switch }}
  | letin e          ::  :: letin
  | ( e )            :: S:: paren  {{ coq ([[e]]) }}
  | 0                :: S:: zero   {{ coq }}
  | 1                :: S:: one    {{ coq }}
  | 2                :: S:: two    {{ coq }}
  | e1 + e2          :: S:: plus   {{ coq }}

val, v :: 'v_' ::= {{ com values }}
  | {}               ::  :: top
  | null             ::  :: null
  | int              ::  :: int
  | \ x : A . e : B  ::  :: abs
  | { l = v }        ::  :: rcd
  | v1 ,, v2         ::  :: merge

letin :: 'letin_' ::= {{ com let-in bindings }}
  | id            ::  :: identity
  | letin letin'  ::  :: composition {{ tex [[letin]]\circ[[letin']] }}
  | let x = e in  ::  :: bind

ctx, G {{ tex \Gamma }} :: 'ctx_' ::= {{ com typing context }} {{ coq list (nat * typ) }}
  | []         ::  :: nil   {{ tex \cdot }} {{ coq nil }}
  | G , x : A  ::  :: cons  {{ coq (([[x]],[[A]])::[[G]]) }}

%%%%% source calculus %%%%%

styp, As {{ tex \mathcal{A} }}, Bs {{ tex \mathcal{B} }} :: 'st_' ::= {{ com source types }}
  | Int         ::  :: int    {{ com integer type }} {{ tex \mathbb{Z} }}
  | As -> Bs    ::  :: arrow  {{ com function type }}
  | { P } -> Bs ::  :: narrow {{ com function type with named parameters }}
  | ( As )      :: S:: paren  {{ coq ([[As]]) }}

nptyp, P {{ tex \mathcal{P} }} :: 'pt_' ::= {{ com named parameter types }}
  | []           ::  :: empty    {{ com empty }} {{ tex \cdot }}
  | l : As ; P   ::  :: required {{ com required parameter }}
  | l ? : As ; P ::  :: optional {{ com optional parameter }}
  | ( P )        :: S:: paren    {{ coq ([[P]]) }}

sexp, es {{ tex \epsilon }} :: 'se_' ::= {{ com source expressions }}
  | int               ::  :: int   {{ com integer literal }} {{ tex n }}
  | x                 ::  :: var   {{ com variable }}
  | \ ( x : As ) . es ::  :: abs   {{ com abstraction }}
                                   {{ tex [[\]]([[x]]\!:\![[As]]).\;[[es]] }}
  | es1 es2           ::  :: app   {{ com application }}
  | \ { p } . es      ::  :: nabs  {{ com abstraction with named parameters }}
                                   {{ tex [[\]]\{[[p]]\}.\;[[es]] }}
  | es { a }          ::  :: napp  {{ com application to named arguments }}
                                   {{ tex [[es]]\,\{[[a]]\} }}
  | ( es )            :: S:: paren {{ coq ([[es]]) }}
  | 0                 :: S:: zero  {{ coq }}
  | 1                 :: S:: one   {{ coq }}
  | 2                 :: S:: two   {{ coq }}
  | es1 + es2         :: S:: plus  {{ coq }}

npexp, p {{ tex \rho }} :: 'par_' ::= {{ com named parameters }}
  | []         ::  :: empty    {{ com empty }} {{ tex \cdot }}
  | l : As ; p ::  :: required {{ com required parameter }}
  | l = es ; p ::  :: optional {{ com optional parameter }}
  | ( p )      :: S:: paren    {{ coq ([[p]]) }}

narg, a {{ tex \alpha }} :: 'arg_' ::= {{ com named arguments }}
  | []         ::  :: empty   {{ com empty }} {{ tex \cdot }}
  | l = es ; a ::  :: field   {{ com field }}
  | a \\ l     :: M:: removal {{ com removal }} {{ coq (remove[[l]][[a]]) }}
  | ( a )      :: S:: paren   {{ coq ([[a]]) }}

sctx, Gs {{ tex \Delta }} :: 'sctx_' ::= {{ com typing context }} {{ coq list (nat * styp) }}
  | []          ::  :: nil  {{ tex \cdot }} {{ coq nil }}
  | Gs , x : As ::  :: cons {{ coq (([[x]],[[As]])::[[Gs]]) }}

terminals :: 'terminals_' ::=
  | \    ::  :: lambda     {{ tex \lambda }}
  | ->   ::  :: arrow      {{ tex \rightarrow }}
  | -->  ::  :: larrow     {{ tex \longrightarrow }}
  | ~~>  ::  :: sarrow     {{ tex \,\rightsquigarrow\, }}
  | =>   ::  :: farrow     {{ tex \Rightarrow }}
  | =/>  ::  :: nfarrow    {{ tex \nRightarrow }}
  | |-   ::  :: turnstile  {{ tex \,\vdash\, }}
  | -|   ::  :: rturnstile {{ tex \,\dashv\, }}
  | ~    ::  :: consistent {{ tex \approx }}
  | &    ::  :: and        {{ tex \land  }}
  | |    ::  :: or         {{ tex \lor }}
  | ||   ::  :: pipe       {{ tex | }}
  | \\   ::  :: backslash  {{ tex \backslash }}
  | ,,   ::  :: merge      {{ tex \bbcomma }}
  | <>   ::  :: diamond    {{ tex \,\diamond\, }}
  | /=   ::  :: neq        {{ tex \neq }}
  | ,    ::  :: comma      {{ tex ,\, }}

formula :: 'formula_' ::=
  | judgement     ::  :: judgement
  | uniq G        :: M:: uniqG     {{ tex }} {{ coq (uniq[[G]]) }}
  | x : A in G    :: M:: inG       {{ tex [[x]][[:]][[A]]\in[[G]] }}
                                   {{ coq (binds[[x]][[A]][[G]]) }}
  | uniq Gs       :: M:: uniqGs    {{ tex }} {{ coq (uniq[[Gs]]) }}
  | x : As in Gs  :: M:: inGs      {{ tex [[x]][[:]][[As]]\in[[Gs]] }}
                                   {{ coq (binds[[x]][[As]][[Gs]]) }}
  | x notin Gs    :: M:: fresh     {{ tex \mathbf{fresh}\,[[x]] }}
                                   {{ coq (fresh[[x]][[Gs]]) }}
  | A = B         :: M:: eqTyp     {{ coq ([[A]]=[[B]]) }}
  | l /= l'       :: M:: neqLabel  {{ coq l <> l' }}

parsing
  t_arrow <= t_and
  t_arrow right t_arrow
  e_merge left e_merge
  se_abs <= se_plus
  se_nabs <= se_plus

subrules
  val <:: exp

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

embed
{{ coq
Fixpoint remove (l : nat) (a : narg) :=
  match a with
    | arg_empty => arg_empty
    | arg_field l' es a' => let a'' := remove l a' in
                            if l =? l' then a''
                            else arg_field l' es a''
  end.
}}

funs
Trans ::=

fun
|| As || :: A :: trans
{{ com Type translation }}
by
||Int|| === Int
||As -> Bs|| === ||As|| -> ||Bs||
||{P} -> Bs|| === ||P|| -> ||Bs||

fun
|| P || :: A :: ptrans
{{ com Parameter type translation }}
by
||[]|| === Top
||l:As; P|| === { l: ||As|| } & ||P||
||l?:As; P|| === { l: ||As|| | Null } & ||P||

funs
CtxTrans ::=
fun
|| Gs || :: G :: ctxtrans
{{ com Typing context translation }}
by
||[]|| === []
||Gs, x:As|| === ||Gs||, x:||As||

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Target :: '' ::=

defn
A <: B :: :: sub :: Sub_
{{ com Subtyping }}
by

--------------- :: Top
A <: Top


--------------- :: Bot
Bot <: A


--------------- :: Int
Int <: Int


B1 <: A1
A2 <: B2
------------------------ :: Arrow
A1 -> A2 <: B1 -> B2


A <: B
------------------------ :: Rcd
{l:A} <: {l:B}


A <: B
A <: C
------------------------ :: And
A <: B & C


A <: C
------------------------ :: AndL
A & B <: C


B <: C
------------------------ :: AndR
A & B <: C


A <: C
B <: C
------------------------ :: Or
A | B <: C


A <: B
------------------------ :: OrL
A <: B | C


A <: C
------------------------ :: OrR
A <: B | C



defn
G |- e : A :: :: typing :: Typ_
{{ com Typing }}
by

uniq G
----------------- :: Top
G |- {} : Top


uniq G
----------------- :: Int
G |- int : Int


x : A in G
uniq G
----------------- :: Var
G |- x : A


G, x : A |- e : B
----------------------------- :: Abs
G |- (\x : A . e : B) : A->B


G |- e1 : A -> B
G |- e2 : A
----------------------- :: App
G |- e1 e2 : B


G |- e : A
----------------------- :: Rcd
G |- {l=e} : {l:A}


G |- e : {l:A}
----------------------- :: Prj
G |- e.l : A


G |- e1 : A
G |- e2 : B
----------------------- :: Merge
G |- e1 ,, e2 : A & B


G |- e : A | B
G, x : A |- e1 : C
G, x : B |- e2 : C
-------------------------------------------------- :: Switch
G |- switch e0 as x case A => e1 case B => e2 : C


G |- letin -| G'
G' |- e : A
----------------- :: Let
G |- letin e : A


G |- e : A
A <: B
----------------- :: Sub
G |- e : B



defn
G |- letin -| G' :: :: letbind :: LB_
{{ com Let-in binding }}
by

G |- e : A
--------------------------- :: Let
G |- let x = e in -| G, x:A


G |- letin1 -| G'
G' |- letin2 -| G''
------------------------- :: Comp
G |- letin1 letin2 -| G''


------------ :: Id
G |- id -| G

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
Source :: '' ::=

defn
Gs |- es : As ~~> e :: :: elab :: Ela_
{{ com Elaboration }}
by

uniq Gs
----------------------- :: Int
Gs |- int : Int ~~> int


x : As in Gs
uniq Gs
------------------ :: Var
Gs |- x : As ~~> x


Gs,x:As |- es : Bs ~~> e
||As|| = A
||Bs|| = B
-------------------------------------- :: Abs
Gs |- \(x:As).es : As->Bs ~~> \x:A.e:B


Gs |- es1 : As -> Bs ~~> e1
Gs |- es2 : As ~~> e2
---------------------------- :: App
Gs |- es1 es2 : Bs ~~> e1 e2


x notin Gs'
uniq Gs'
Gs; x |- p : P ~~> letin -| Gs'
Gs' |- es : Bs ~~> e
||P|| = A
||Bs|| = B
------------------------------------------ :: NAbs
Gs |- \{p}.es : {P}->Bs ~~> \x:A.letin e:B


Gs |- es : {P} -> Bs ~~> e
Gs |- P <> a ~~> e'
-------------------------- :: NApp
Gs |- es {a} : Bs ~~> e e'



defn
Gs ; x |- p : P ~~> letin -| Gs' :: :: pelab :: PEla_
{{ com Parameter elaboration }}
by

----------------------------- :: Empty
Gs; x |- [] : [] ~~> id -| Gs


Gs; x |- p : P ~~> letin -| Gs'
-------------------------------------------------------------------- :: Required
Gs; x |- (l:As; p) : (l:As; P) ~~> let l = x.l in letin -| Gs', l:As


Gs |- es : As ~~> e
||As|| = A
Gs; x |- p : P ~~> letin -| Gs'
------------------------------------------------------------------------------------------------------------ :: Optional
Gs; x |- (l=es; p) : (l?:As; P) ~~> let l = switch x.l as y case A => y case Null => e in letin -| Gs', l:As



defn
Gs |- P <> a ~~> e :: :: pmatch :: PMat_
{{ com Parameter matching }}
by

--------------------- :: Empty
Gs |- [] <> [] ~~> {}


Gs |- es : As ~~> e
Gs |- [] <> a ~~> e'
----------------------------------- :: Extra
Gs |- [] <> (l=es; a) ~~> {l=e},,e'


a.l => es
Gs |- es : As ~~> e
Gs |- P <> a\\l ~~> e'
---------------------------------- :: Present
Gs |- (l:As; P) <> a ~~> {l=e},,e'


a.l =/>
Gs |- P <> a ~~> e'
------------------------------------- :: Absent
Gs |- (l:As; P) <> a ~~> {l=null},,e'



defn
a . l => es :: :: lookup :: LU_
{{ com Successful lookup }}
by

a.l =/>
--------------------- :: Field
(l = es ; a').l => es


defn
a . l =/> :: :: lookdown :: LD_
{{ com Failed lookup }}
by

-------- :: Empty
[].l =/>


l' /= l
a.l =/>
------------------- :: Field
(l' = es ; a).l =/>
