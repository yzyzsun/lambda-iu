(* generated by Ott 0.33, locally-nameless from: lambda-iu.ott *)
Require Import Bool.
Require Import Metalib.Metatheory.
Require Import List.
Require Import Ott.ott_list_core.
(** syntax *)
Definition index : Set := nat.

Inductive typ : Set :=  (*r types *)
 | t_top : typ (*r top type *)
 | t_bot : typ (*r bottom type *)
 | t_null : typ (*r null type *)
 | t_int : typ (*r integer type *)
 | t_arrow (A:typ) (B:typ) (*r function type *)
 | t_rcd (l:var) (A:typ) (*r record type *)
 | t_and (A:typ) (B:typ) (*r intersection type *)
 | t_or (A:typ) (B:typ) (*r union type *).

Inductive styp : Set :=  (*r source types *)
 | st_int : styp (*r integer type *)
 | st_arrow (As:styp) (Bs:styp) (*r function type *)
 | st_narrow (P:nptyp) (Bs:styp) (*r function type with named parameters *)
with nptyp : Set :=  (*r named parameter types *)
 | pt_empty : nptyp (*r empty *)
 | pt_required (l:var) (As:styp) (P:nptyp) (*r required parameter *)
 | pt_optional (l:var) (As:styp) (P:nptyp) (*r optional parameter *).

Definition ctx : Set := list (atom * typ).

Inductive exp : Set :=  (*r expressions *)
 | e_top : exp (*r top value *)
 | e_null : exp (*r null value *)
 | e_int : exp (*r integer literal *)
 | e_var_b (_:nat) (*r variable *)
 | e_var_f (x:var) (*r variable *)
 | e_abs (x:var) (A:typ) (e:exp) (B:typ) (*r abstraction *)
 | e_app (e1:exp) (e2:exp) (*r application *)
 | e_rcd (l:var) (e:exp) (*r record *)
 | e_prj (e:exp) (l:var) (*r projection *)
 | e_merge (e1:exp) (e2:exp) (*r merging *)
 | e_switch (e0:exp) (x:var) (A:typ) (e1:exp) (B:typ) (e2:exp) (*r type switch *)
 | e_letin (letin5:letin) (e:exp)
with letin : Set :=  (*r let-in bindings *)
 | letin_identity : letin
 | letin_composition (letin5:letin) (letin':letin)
 | letin_bind (x:var) (e:exp).

Definition sctx : Set := list (atom * styp).

Inductive sexp : Set :=  (*r source expressions *)
 | se_int : sexp (*r integer literal *)
 | se_var_b (_:nat) (*r variable *)
 | se_var_f (x:var) (*r variable *)
 | se_abs (x:var) (As:styp) (es:sexp) (*r abstraction *)
 | se_app (es1:sexp) (es2:sexp) (*r application *)
 | se_nabs (p:npexp) (es:sexp) (*r abstraction with named parameters *)
 | se_napp (es:sexp) (a:narg) (*r application to named arguments *)
with npexp : Set :=  (*r named parameters *)
 | par_empty : npexp (*r empty *)
 | par_required (l:var) (As:styp) (p:npexp) (*r required parameter *)
 | par_optional (l:var) (es:sexp) (p:npexp) (*r optional parameter *)
with narg : Set :=  (*r named arguments *)
 | arg_empty : narg (*r empty *)
 | arg_field (l:var) (es:sexp) (a:narg) (*r field *)
 | arg_removal (a:narg) (l:var) (*r removal *).

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
Fixpoint is_val_of_exp (e_5:exp) : bool :=
  match e_5 with
  | e_top => (true)
  | e_null => (true)
  | e_int => (true)
  | (e_var_b nat) => false
  | (e_var_f x) => false
  | (e_abs x A e B) => (true)
  | (e_app e1 e2) => false
  | (e_rcd l e) => ((is_val_of_exp e))
  | (e_prj e l) => false
  | (e_merge e1 e2) => ((is_val_of_exp e1) && (is_val_of_exp e2))
  | (e_switch e0 x A e1 B e2) => false
  | (e_letin letin5 e) => false
end.

(** arities *)
(** opening up abstractions *)
Fixpoint open_narg_wrt_sexp_rec (k:nat) (es5:sexp) (a5:narg) {struct a5}: narg :=
  match a5 with
  | arg_empty => arg_empty 
  | (arg_field l es a) => arg_field l (open_sexp_wrt_sexp_rec k es5 es) (open_narg_wrt_sexp_rec k es5 a)
  | (arg_removal a l) => arg_removal (open_narg_wrt_sexp_rec k es5 a) l
end
with open_npexp_wrt_sexp_rec (k:nat) (es5:sexp) (p5:npexp) {struct p5}: npexp :=
  match p5 with
  | par_empty => par_empty 
  | (par_required l As p) => par_required l As (open_npexp_wrt_sexp_rec k es5 p)
  | (par_optional l es p) => par_optional l (open_sexp_wrt_sexp_rec k es5 es) (open_npexp_wrt_sexp_rec k es5 p)
end
with open_sexp_wrt_sexp_rec (k:nat) (es_5:sexp) (es__6:sexp) {struct es__6}: sexp :=
  match es__6 with
  | se_int => se_int 
  | (se_var_b nat) => if (k === nat) then es_5 else (se_var_b nat)
  | (se_var_f x) => se_var_f x
  | (se_abs x As es) => se_abs x As (open_sexp_wrt_sexp_rec k es_5 es)
  | (se_app es1 es2) => se_app (open_sexp_wrt_sexp_rec k es_5 es1) (open_sexp_wrt_sexp_rec k es_5 es2)
  | (se_nabs p es) => se_nabs (open_npexp_wrt_sexp_rec k es_5 p) (open_sexp_wrt_sexp_rec k es_5 es)
  | (se_napp es a) => se_napp (open_sexp_wrt_sexp_rec k es_5 es) (open_narg_wrt_sexp_rec k es_5 a)
end.

Fixpoint open_letin_wrt_exp_rec (k:nat) (e5:exp) (letin_6:letin) {struct letin_6}: letin :=
  match letin_6 with
  | letin_identity => letin_identity 
  | (letin_composition letin5 letin') => letin_composition (open_letin_wrt_exp_rec k e5 letin5) (open_letin_wrt_exp_rec k e5 letin')
  | (letin_bind x e) => letin_bind x (open_exp_wrt_exp_rec k e5 e)
end
with open_exp_wrt_exp_rec (k:nat) (e_5:exp) (e__6:exp) {struct e__6}: exp :=
  match e__6 with
  | e_top => e_top 
  | e_null => e_null 
  | e_int => e_int 
  | (e_var_b nat) => if (k === nat) then e_5 else (e_var_b nat)
  | (e_var_f x) => e_var_f x
  | (e_abs x A e B) => e_abs x A (open_exp_wrt_exp_rec k e_5 e) B
  | (e_app e1 e2) => e_app (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)
  | (e_rcd l e) => e_rcd l (open_exp_wrt_exp_rec k e_5 e)
  | (e_prj e l) => e_prj (open_exp_wrt_exp_rec k e_5 e) l
  | (e_merge e1 e2) => e_merge (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)
  | (e_switch e0 x A e1 B e2) => e_switch (open_exp_wrt_exp_rec k e_5 e0) x A (open_exp_wrt_exp_rec k e_5 e1) B (open_exp_wrt_exp_rec k e_5 e2)
  | (e_letin letin5 e) => e_letin (open_letin_wrt_exp_rec k e_5 letin5) (open_exp_wrt_exp_rec k e_5 e)
end.

Definition open_narg_wrt_sexp es5 a5 := open_narg_wrt_sexp_rec 0 a5 es5.

Definition open_npexp_wrt_sexp es5 p5 := open_npexp_wrt_sexp_rec 0 p5 es5.

Definition open_sexp_wrt_sexp es_5 es__6 := open_sexp_wrt_sexp_rec 0 es__6 es_5.

Definition open_letin_wrt_exp e5 letin_6 := open_letin_wrt_exp_rec 0 letin_6 e5.

Definition open_exp_wrt_exp e_5 e__6 := open_exp_wrt_exp_rec 0 e__6 e_5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_letin_exp *)
Inductive lc_letin : letin -> Prop :=    (* defn lc_letin *)
 | lc_letin_identity : 
     (lc_letin letin_identity)
 | lc_letin_composition : forall (letin5 letin':letin),
     (lc_letin letin5) ->
     (lc_letin letin') ->
     (lc_letin (letin_composition letin5 letin'))
 | lc_letin_bind : forall (x:var) (e:exp),
     (lc_exp e) ->
     (lc_letin (letin_bind x e))
with lc_exp : exp -> Prop :=    (* defn lc_exp *)
 | lc_e_top : 
     (lc_exp e_top)
 | lc_e_null : 
     (lc_exp e_null)
 | lc_e_int : 
     (lc_exp e_int)
 | lc_e_var_f : forall (x:var),
     (lc_exp (e_var_f x))
 | lc_e_abs : forall (x:var) (A:typ) (e:exp) (B:typ),
     (lc_exp e) ->
     (lc_exp (e_abs x A e B))
 | lc_e_app : forall (e1 e2:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (e_app e1 e2))
 | lc_e_rcd : forall (l:var) (e:exp),
     (lc_exp e) ->
     (lc_exp (e_rcd l e))
 | lc_e_prj : forall (e:exp) (l:var),
     (lc_exp e) ->
     (lc_exp (e_prj e l))
 | lc_e_merge : forall (e1 e2:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (e_merge e1 e2))
 | lc_e_switch : forall (e0:exp) (x:var) (A:typ) (e1:exp) (B:typ) (e2:exp),
     (lc_exp e0) ->
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (e_switch e0 x A e1 B e2))
 | lc_e_letin : forall (letin5:letin) (e:exp),
     (lc_letin letin5) ->
     (lc_exp e) ->
     (lc_exp (e_letin letin5 e)).

(* defns LC_narg_npexp_sexp *)
Inductive lc_narg : narg -> Prop :=    (* defn lc_narg *)
 | lc_arg_empty : 
     (lc_narg arg_empty)
 | lc_arg_field : forall (l:var) (es:sexp) (a:narg),
     (lc_sexp es) ->
     (lc_narg a) ->
     (lc_narg (arg_field l es a))
 | lc_arg_removal : forall (a:narg) (l:var),
     (lc_narg a) ->
     (lc_narg (arg_removal a l))
with lc_npexp : npexp -> Prop :=    (* defn lc_npexp *)
 | lc_par_empty : 
     (lc_npexp par_empty)
 | lc_par_required : forall (l:var) (As:styp) (p:npexp),
     (lc_npexp p) ->
     (lc_npexp (par_required l As p))
 | lc_par_optional : forall (l:var) (es:sexp) (p:npexp),
     (lc_sexp es) ->
     (lc_npexp p) ->
     (lc_npexp (par_optional l es p))
with lc_sexp : sexp -> Prop :=    (* defn lc_sexp *)
 | lc_se_int : 
     (lc_sexp se_int)
 | lc_se_var_f : forall (x:var),
     (lc_sexp (se_var_f x))
 | lc_se_abs : forall (x:var) (As:styp) (es:sexp),
     (lc_sexp es) ->
     (lc_sexp (se_abs x As es))
 | lc_se_app : forall (es1 es2:sexp),
     (lc_sexp es1) ->
     (lc_sexp es2) ->
     (lc_sexp (se_app es1 es2))
 | lc_se_nabs : forall (p:npexp) (es:sexp),
     (lc_npexp p) ->
     (lc_sexp es) ->
     (lc_sexp (se_nabs p es))
 | lc_se_napp : forall (es:sexp) (a:narg),
     (lc_sexp es) ->
     (lc_narg a) ->
     (lc_sexp (se_napp es a)).
(** free variables *)
(** substitutions *)

(** definitions *)

(* defns Aux *)
Inductive letbind : ctx -> letin -> ctx -> Prop :=    (* defn letbind *)
with lookup : narg -> var -> sexp -> Prop :=    (* defn lookup *)
with nolookup : narg -> var -> Prop :=    (* defn nolookup *).

(* defns Statics *)
Inductive sub : typ -> typ -> Prop :=    (* defn sub *)
 | Sub_Top : forall (A:typ),
     sub A t_top
 | Sub_Bot : forall (A:typ),
     sub t_bot A
 | Sub_Int : 
     sub t_int t_int
 | Sub_Arrow : forall (A1 A2 B1 B2:typ),
     sub B1 A1 ->
     sub A2 B2 ->
     sub (t_arrow A1 A2) (t_arrow B1 B2)
 | Sub_Rcd : forall (l:var) (A B:typ),
     sub A B ->
     sub (t_rcd l A) (t_rcd l B)
 | Sub_And : forall (A B C:typ),
     sub A B ->
     sub A C ->
     sub A (t_and B C)
 | Sub_AndL : forall (A B C:typ),
     sub A C ->
     sub (t_and A B) C
 | Sub_AndR : forall (A B C:typ),
     sub B C ->
     sub (t_and A B) C
 | Sub_Or : forall (A B C:typ),
     sub A C ->
     sub B C ->
     sub (t_or A B) C
 | Sub_OrL : forall (A B C:typ),
     sub A B ->
     sub A (t_or B C)
 | Sub_OrR : forall (A B C:typ),
     sub A C ->
     sub A (t_or B C)
with typing : ctx -> exp -> typ -> Prop :=    (* defn typing *)
 | Typ_Top : forall (G:ctx),
      (uniq G )  ->
     typing G e_top t_top
 | Typ_Int : forall (G:ctx),
      (uniq G )  ->
     typing G e_int t_int
 | Typ_Var : forall (G:ctx) (x:var) (A:typ),
      (binds x A G )  ->
      (uniq G )  ->
     typing G (e_var_f x) A
 | Typ_Abs : forall (G:ctx) (x:var) (A:typ) (e:exp) (B:typ),
     typing  ( x ~ A ++ G )  e B ->
     typing G  ( (e_abs x A e B) )  (t_arrow A B)
 | Typ_App : forall (G:ctx) (e1 e2:exp) (B A:typ),
     typing G e1 (t_arrow A B) ->
     typing G e2 A ->
     typing G (e_app e1 e2) B
 | Typ_Rcd : forall (G:ctx) (l:var) (e:exp) (A:typ),
     typing G e A ->
     typing G (e_rcd l e) (t_rcd l A)
 | Typ_Prj : forall (G:ctx) (e:exp) (l:var) (A:typ),
     typing G e (t_rcd l A) ->
     typing G (e_prj e l) A
 | Typ_Merge : forall (G:ctx) (e1 e2:exp) (A B:typ),
     typing G e1 A ->
     typing G e2 B ->
     typing G (e_merge e1 e2) (t_and A B)
 | Typ_Switch : forall (G:ctx) (e0:exp) (x:var) (A:typ) (e1:exp) (B:typ) (e2:exp) (C:typ) (e:exp),
     lc_exp e0 ->
     typing G e (t_or A B) ->
     typing  ( x ~ A ++ G )  e1 C ->
     typing  ( x ~ B ++ G )  e2 C ->
     typing G (e_switch e0 x A e1 B e2) C
 | Typ_Let : forall (G:ctx) (letin5:letin) (e:exp) (A:typ) (G':ctx),
     letbind G letin5 G' ->
     typing G' e A ->
     typing G (e_letin letin5 e) A
 | Typ_Sub : forall (G:ctx) (e:exp) (B A:typ),
     typing G e A ->
     sub A B ->
     typing G e B.

(* defns Source *)
Inductive trans : styp -> typ -> Prop :=    (* defn trans *)
 | Tr_Int : 
     trans st_int t_int
 | Tr_Arrow : forall (As Bs:styp) (A B:typ),
     trans As A ->
     trans Bs B ->
     trans (st_arrow As Bs) (t_arrow A B)
 | Tr_NArrow : forall (P:nptyp) (Bs:styp) (A B:typ),
     ptrans P A ->
     trans Bs B ->
     trans (st_narrow P Bs) (t_arrow A B)
with ptrans : nptyp -> typ -> Prop :=    (* defn ptrans *)
 | PTr_Empty : 
     ptrans pt_empty t_top
 | PTr_Required : forall (l:var) (As:styp) (P:nptyp) (A B:typ),
     ptrans P B ->
     ptrans (pt_required l As P) (t_and (t_rcd l A) B)
 | PTr_Optional : forall (l:var) (As:styp) (P:nptyp) (A B:typ),
     ptrans P B ->
     ptrans (pt_optional l As P) (t_and (t_rcd l (t_or A t_null)) B)
with ctxtrans : sctx -> ctx -> Prop :=    (* defn ctxtrans *)
 | GTr_Nil : 
     ctxtrans  nil   nil 
 | GTr_Cons : forall (Gs:sctx) (x:var) (As:styp) (G:ctx) (A:typ),
     ctxtrans Gs G ->
     trans As A ->
     ctxtrans  ( x ~ As ++ Gs )   ( x ~ A ++ G ) 
with elab : sctx -> sexp -> styp -> exp -> Prop :=    (* defn elab *)
 | Ela_Int : forall (Gs:sctx),
      (uniq Gs )  ->
     elab Gs se_int st_int e_int
 | Ela_Var : forall (Gs:sctx) (x:var) (As:styp),
      (binds x As Gs )  ->
      (uniq Gs )  ->
     elab Gs (se_var_f x) As (e_var_f x)
 | Ela_Abs : forall (Gs:sctx) (x:var) (As:styp) (es:sexp) (Bs:styp) (A:typ) (e:exp) (B:typ),
     elab  ( x ~ As ++ Gs )  es Bs e ->
     trans As A ->
     trans Bs B ->
     elab Gs (se_abs x As es) (st_arrow As Bs) (e_abs x A e B)
 | Ela_App : forall (Gs:sctx) (es1 es2:sexp) (Bs:styp) (e1 e2:exp) (As:styp),
     elab Gs es1 (st_arrow As Bs) e1 ->
     elab Gs es2 As e2 ->
     elab Gs (se_app es1 es2) Bs (e_app e1 e2)
 | Ela_NAbs : forall (Gs:sctx) (p:npexp) (es:sexp) (P:nptyp) (Bs:styp) (x:var) (A:typ) (letin5:letin) (e:exp) (B:typ) (Gs':sctx),
      True  ->
     pelab Gs x p P letin5 Gs' ->
     elab Gs' es Bs e ->
     ptrans P A ->
     trans Bs B ->
     elab Gs (se_nabs p es) (st_narrow P Bs) (e_abs x A (e_letin letin5 e) B)
 | Ela_NApp : forall (Gs:sctx) (es:sexp) (a:narg) (Bs:styp) (e e':exp) (P:nptyp),
     elab Gs es (st_narrow P Bs) e ->
     pmatch Gs P a e' ->
     elab Gs (se_napp es a) Bs (e_app e e')
with pelab : sctx -> var -> npexp -> nptyp -> letin -> sctx -> Prop :=    (* defn pelab *)
 | PEla_Empty : forall (Gs:sctx) (x:var),
     pelab Gs x par_empty pt_empty letin_identity Gs
 | PEla_Required : forall (Gs:sctx) (x l:var) (As:styp) (p:npexp) (P:nptyp) (letin5:letin) (Gs':sctx),
     pelab Gs x p P letin5 Gs' ->
     pelab Gs x  ( (par_required l As p) )   ( (pt_required l As P) )  (letin_composition (letin_bind l (e_prj (e_var_f x) l)) letin5)  ( l ~ As ++ Gs' ) 
 | PEla_Optional : forall (Gs:sctx) (x l:var) (es:sexp) (p:npexp) (As:styp) (P:nptyp) (y:var) (A:typ) (e:exp) (letin5:letin) (Gs':sctx),
     elab Gs es As e ->
     trans As A ->
     pelab Gs x p P letin5 Gs' ->
     pelab Gs x  ( (par_optional l es p) )   ( (pt_optional l As P) )  (letin_composition (letin_bind l (e_switch (e_prj (e_var_f x) l) y A (e_var_f y) t_null e)) letin5)  ( l ~ As ++ Gs' ) 
with pmatch : sctx -> nptyp -> narg -> exp -> Prop :=    (* defn pmatch *)
 | PMat_Empty : forall (Gs:sctx),
     pmatch Gs pt_empty arg_empty e_top
 | PMat_Extra : forall (Gs:sctx) (l:var) (es:sexp) (a:narg) (e e':exp) (As:styp),
     elab Gs es As e ->
     pmatch Gs pt_empty a e' ->
     pmatch Gs pt_empty  ( (arg_field l es a) )  (e_merge (e_rcd l e) e')
 | PMat_Present : forall (Gs:sctx) (l:var) (As:styp) (P:nptyp) (a:narg) (e e':exp) (es:sexp),
     lookup a l es ->
     elab Gs es As e ->
     pmatch Gs P (arg_removal a l) e' ->
     pmatch Gs  ( (pt_required l As P) )  a (e_merge (e_rcd l e) e')
 | PMat_Absent : forall (Gs:sctx) (l:var) (As:styp) (P:nptyp) (a:narg) (e':exp),
     nolookup a l ->
     pmatch Gs P a e' ->
     pmatch Gs  ( (pt_required l As P) )  a (e_merge (e_rcd l e_null) e').


(** infrastructure *)
Hint Constructors letbind lookup nolookup sub typing trans ptrans ctxtrans elab pelab pmatch lc_letin lc_exp lc_narg lc_npexp lc_sexp : core.


